// const mongoose = require('./mongoose');
const bcrypt = require("bcrypt")
const mongoose = require("mongoose")

const AdminSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: false,
  },
  lastName: {
    type: String,
    required: false,
  },
  administratorSurveys: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Survey",
    },
  ],
  administratorSurveyInvitations: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SurveyInvitation",
    },
  ],
  email: {
    type: String,
    required: false,
  },
  creationDate: {
    type: Date,
    default: Date.now,
  },
  updateDate: {
    type: Date,
    default: Date.now,
  },
  isDeleted: {
    type: Boolean,
    defaults: false,
  },

  
  password: {
    type: String,
    required: false,
  },
  super: {
    type: Boolean,
    required: false,
  },
  description: {
    type: String,
    required: false,
  },
})
//function to hash the user entered password into hash format before saving
AdminSchema.pre("save", async function (next) {
  if (this.isModified("password")) {
    this.password = await bcrypt.hash(this.password, 10) //The salt in the code bcrypt.hash(this.password, 10) is generated by the bcrypt library. The library generates a random string of 22 characters, and it uses the base64 encoding scheme to encode the string. This ensures that the salt is strong and that it is compatible with bcrypt.....The first part of the hash is the salt, and the second part of the hash is the password hash.
  }
  next()
})

//Function to comparare the user entered password to the password stored in databse in hashed format
AdminSchema.methods.comparePassword = async function (password) {
  return await bcrypt.compare(password, this.password) //When you need to verify the password, you will need to use the salt to hash the password again. If the two hashes match, then the password is correct
}

const AdminModel = mongoose.model("Admin", AdminSchema)

module.exports = AdminModel
